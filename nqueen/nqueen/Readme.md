# N-queens
##主要思想是试探和回溯
###试探阶段
当第r行的皇后的位置确定好以后，就要改变棋盘的可行域：皇后所在的列，以及皇后的两个对角线的格子的值加一。实际上，这是缩小了继续试探的范围，所以只会影响到(r,N)行的皇后的位置。所以只用修改r行以后的棋盘的可行域就可以了。

###回溯阶段
当要撤销第r行的皇后的位置时，需要将可行域恢复到放置第r行皇后时的样子：将皇后所在列，以及俩对角线的格子的值减一。同样只用恢复r行以后的棋盘。

##算法流程

算法维护了三个主要的数据结构：两个栈（stack和queen），一个矩阵board。
stack用来保存还没试探过的棋盘的坐标序列，方便回溯以消除递归。
queen保存当前试探出的解。
board保存解为queen中的坐标序列时，棋盘的可行区域和不可行区域。
board是整数矩阵，里面的值为零表示该坐标可行，大于零表示不可行。


+ 首先将棋盘第一行坐标压入stack中。

+ 如果栈stack非空，则用stack栈顶的坐标与queen比较：

  * 试探：（若queen为空），或者（stack.back()是queen.back()的下一行），则
    1. 将stack栈顶弹出，然后压入queen中；（把这个格子选定为皇后）
    2. 根据皇后的位置修改棋盘的可行域board；
    3. 根据新的棋盘，将下一行的可行坐标压入stack中
    4. 最后判断一下当前行是不是最后一行。若是，说明queen里的序列就是一个可行解序列。输出之。

  * 回溯：（如果queen非空），且（stack.back()与queen.back()在同一层或者stack.back()在上层），则说明下一层的点已经遍历完了，需要更换新的皇后坐标：
    1. 按照queen.back()的位置恢复到设定这个皇后之前的棋盘
    2. 将queen.back()弹出。
